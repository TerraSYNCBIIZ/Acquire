{
  "version": 3,
  "sources": ["../../partysocket/src/ws.ts", "../../partysocket/src/index.ts"],
  "sourcesContent": ["// TODO: lose this eslint-disable\n\n/*!\n * Reconnecting WebSocket\n * by Pedro Ladaria <pedro.ladaria@gmail.com>\n * https://github.com/pladaria/reconnecting-websocket\n * License MIT\n */\n\nimport type { TypedEventTarget } from \"./type-helper\";\n\nif (!globalThis.EventTarget || !globalThis.Event) {\n  console.error(`\n  PartySocket requires a global 'EventTarget' class to be available!\n  You can polyfill this global by adding this to your code before any partysocket imports: \n  \n  \\`\\`\\`\n  import 'partysocket/event-target-polyfill';\n  \\`\\`\\`\n  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.\n`);\n}\n\nexport class ErrorEvent extends Event {\n  public message: string;\n  public error: Error;\n  // biome-ignore lint/suspicious/noExplicitAny: vibes\n  constructor(error: Error, target: any) {\n    super(\"error\", target);\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\nexport class CloseEvent extends Event {\n  public code: number;\n  public reason: string;\n  public wasClean = true;\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  constructor(code = 1000, reason = \"\", target: any) {\n    super(\"close\", target);\n    this.code = code;\n    this.reason = reason;\n  }\n}\nexport interface WebSocketEventMap {\n  close: CloseEvent;\n  error: ErrorEvent;\n  message: MessageEvent;\n  open: Event;\n}\n\nconst Events = {\n  Event,\n  ErrorEvent,\n  CloseEvent\n};\n\nfunction assert(condition: unknown, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\n\nfunction cloneEventBrowser(e: Event) {\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  return new (e as any).constructor(e.type, e) as Event;\n}\n\nfunction cloneEventNode(e: Event) {\n  if (\"data\" in e) {\n    const evt = new MessageEvent(e.type, e);\n    return evt;\n  }\n\n  if (\"code\" in e || \"reason\" in e) {\n    const evt = new CloseEvent(\n      // @ts-expect-error we need to fix event/listener types\n      (e.code || 1999) as number,\n      // @ts-expect-error we need to fix event/listener types\n      (e.reason || \"unknown reason\") as string,\n      e\n    );\n    return evt;\n  }\n\n  if (\"error\" in e) {\n    const evt = new ErrorEvent(e.error as Error, e);\n    return evt;\n  }\n\n  const evt = new Event(e.type, e);\n  return evt;\n}\n\nconst isNode =\n  typeof process !== \"undefined\" &&\n  typeof process.versions?.node !== \"undefined\" &&\n  typeof document === \"undefined\";\n\nconst cloneEvent = isNode ? cloneEventNode : cloneEventBrowser;\n\nexport type Options = {\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  WebSocket?: any;\n  maxReconnectionDelay?: number;\n  minReconnectionDelay?: number;\n  reconnectionDelayGrowFactor?: number;\n  minUptime?: number;\n  connectionTimeout?: number;\n  maxRetries?: number;\n  maxEnqueuedMessages?: number;\n  startClosed?: boolean;\n  debug?: boolean;\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  debugLogger?: (...args: any[]) => void;\n};\n\nconst DEFAULT = {\n  maxReconnectionDelay: 10000,\n  minReconnectionDelay: 1000 + Math.random() * 4000,\n  minUptime: 5000,\n  reconnectionDelayGrowFactor: 1.3,\n  connectionTimeout: 4000,\n  maxRetries: Number.POSITIVE_INFINITY,\n  maxEnqueuedMessages: Number.POSITIVE_INFINITY,\n  startClosed: false,\n  debug: false\n};\n\nlet didWarnAboutMissingWebSocket = false;\n\nexport type UrlProvider = string | (() => string) | (() => Promise<string>);\nexport type ProtocolsProvider =\n  | null\n  | string\n  | string[]\n  | (() => string | string[] | null)\n  | (() => Promise<string | string[] | null>);\n\nexport type Message = string | ArrayBuffer | Blob | ArrayBufferView;\n\nexport default class ReconnectingWebSocket extends (EventTarget as TypedEventTarget<WebSocketEventMap>) {\n  private _ws: WebSocket | undefined;\n  private _retryCount = -1;\n  private _uptimeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private _connectTimeout: ReturnType<typeof setTimeout> | undefined;\n  private _shouldReconnect = true;\n  private _connectLock = false;\n  private _binaryType: BinaryType = \"blob\";\n  private _closeCalled = false;\n  private _messageQueue: Message[] = [];\n\n  private _debugLogger = console.log.bind(console);\n\n  protected _url: UrlProvider;\n  protected _protocols?: ProtocolsProvider;\n  protected _options: Options;\n\n  constructor(\n    url: UrlProvider,\n    protocols?: ProtocolsProvider,\n    options: Options = {}\n  ) {\n    super();\n    this._url = url;\n    this._protocols = protocols;\n    this._options = options;\n    if (this._options.startClosed) {\n      this._shouldReconnect = false;\n    }\n    if (this._options.debugLogger) {\n      this._debugLogger = this._options.debugLogger;\n    }\n    this._connect();\n  }\n\n  static get CONNECTING() {\n    return 0;\n  }\n  static get OPEN() {\n    return 1;\n  }\n  static get CLOSING() {\n    return 2;\n  }\n  static get CLOSED() {\n    return 3;\n  }\n\n  get CONNECTING() {\n    return ReconnectingWebSocket.CONNECTING;\n  }\n  get OPEN() {\n    return ReconnectingWebSocket.OPEN;\n  }\n  get CLOSING() {\n    return ReconnectingWebSocket.CLOSING;\n  }\n  get CLOSED() {\n    return ReconnectingWebSocket.CLOSED;\n  }\n\n  get binaryType() {\n    return this._ws ? this._ws.binaryType : this._binaryType;\n  }\n\n  set binaryType(value: BinaryType) {\n    this._binaryType = value;\n    if (this._ws) {\n      this._ws.binaryType = value;\n    }\n  }\n\n  /**\n   * Returns the number or connection retries\n   */\n  get retryCount(): number {\n    return Math.max(this._retryCount, 0);\n  }\n\n  /**\n   * The number of bytes of data that have been queued using calls to send() but not yet\n   * transmitted to the network. This value resets to zero once all queued data has been sent.\n   * This value does not reset to zero when the connection is closed; if you keep calling send(),\n   * this will continue to climb. Read only\n   */\n  get bufferedAmount(): number {\n    const bytes = this._messageQueue.reduce((acc, message) => {\n      if (typeof message === \"string\") {\n        acc += message.length; // not byte size\n      } else if (message instanceof Blob) {\n        acc += message.size;\n      } else {\n        acc += message.byteLength;\n      }\n      return acc;\n    }, 0);\n    return bytes + (this._ws ? this._ws.bufferedAmount : 0);\n  }\n\n  /**\n   * The extensions selected by the server. This is currently only the empty string or a list of\n   * extensions as negotiated by the connection\n   */\n  get extensions(): string {\n    return this._ws ? this._ws.extensions : \"\";\n  }\n\n  /**\n   * A string indicating the name of the sub-protocol the server selected;\n   * this will be one of the strings specified in the protocols parameter when creating the\n   * WebSocket object\n   */\n  get protocol(): string {\n    return this._ws ? this._ws.protocol : \"\";\n  }\n\n  /**\n   * The current state of the connection; this is one of the Ready state constants\n   */\n  get readyState(): number {\n    if (this._ws) {\n      return this._ws.readyState;\n    }\n    return this._options.startClosed\n      ? ReconnectingWebSocket.CLOSED\n      : ReconnectingWebSocket.CONNECTING;\n  }\n\n  /**\n   * The URL as resolved by the constructor\n   */\n  get url(): string {\n    return this._ws ? this._ws.url : \"\";\n  }\n\n  /**\n   * Whether the websocket object is now in reconnectable state\n   */\n  get shouldReconnect(): boolean {\n    return this._shouldReconnect;\n  }\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to CLOSED\n   */\n  public onclose: ((event: CloseEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when an error occurs\n   */\n  public onerror: ((event: ErrorEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when a message is received from the server\n   */\n  public onmessage: ((event: MessageEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n   * this indicates that the connection is ready to send and receive data\n   */\n  public onopen: ((event: Event) => void) | null = null;\n\n  /**\n   * Closes the WebSocket connection or connection attempt, if any. If the connection is already\n   * CLOSED, this method does nothing\n   */\n  public close(code = 1000, reason?: string) {\n    this._closeCalled = true;\n    this._shouldReconnect = false;\n    this._clearTimeouts();\n    if (!this._ws) {\n      this._debug(\"close enqueued: no ws instance\");\n      return;\n    }\n    if (this._ws.readyState === this.CLOSED) {\n      this._debug(\"close: already closed\");\n      return;\n    }\n    this._ws.close(code, reason);\n  }\n\n  /**\n   * Closes the WebSocket connection or connection attempt and connects again.\n   * Resets retry counter;\n   */\n  public reconnect(code?: number, reason?: string) {\n    this._shouldReconnect = true;\n    this._closeCalled = false;\n    this._retryCount = -1;\n    if (!this._ws || this._ws.readyState === this.CLOSED) {\n      this._connect();\n    } else {\n      this._disconnect(code, reason);\n      this._connect();\n    }\n  }\n\n  /**\n   * Enqueue specified data to be transmitted to the server over the WebSocket connection\n   */\n  public send(data: Message) {\n    if (this._ws && this._ws.readyState === this.OPEN) {\n      this._debug(\"send\", data);\n      this._ws.send(data);\n    } else {\n      const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } =\n        this._options;\n      if (this._messageQueue.length < maxEnqueuedMessages) {\n        this._debug(\"enqueue\", data);\n        this._messageQueue.push(data);\n      }\n    }\n  }\n\n  private _debug(...args: unknown[]) {\n    if (this._options.debug) {\n      this._debugLogger(\"RWS>\", ...args);\n    }\n  }\n\n  private _getNextDelay() {\n    const {\n      reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor,\n      minReconnectionDelay = DEFAULT.minReconnectionDelay,\n      maxReconnectionDelay = DEFAULT.maxReconnectionDelay\n    } = this._options;\n    let delay = 0;\n    if (this._retryCount > 0) {\n      delay =\n        minReconnectionDelay *\n        reconnectionDelayGrowFactor ** (this._retryCount - 1);\n      if (delay > maxReconnectionDelay) {\n        delay = maxReconnectionDelay;\n      }\n    }\n    this._debug(\"next delay\", delay);\n    return delay;\n  }\n\n  private _wait(): Promise<void> {\n    return new Promise((resolve) => {\n      setTimeout(resolve, this._getNextDelay());\n    });\n  }\n\n  private _getNextProtocols(\n    protocolsProvider: ProtocolsProvider | null\n  ): Promise<string | string[] | null> {\n    if (!protocolsProvider) return Promise.resolve(null);\n\n    if (\n      typeof protocolsProvider === \"string\" ||\n      Array.isArray(protocolsProvider)\n    ) {\n      return Promise.resolve(protocolsProvider);\n    }\n\n    if (typeof protocolsProvider === \"function\") {\n      const protocols = protocolsProvider();\n      if (!protocols) return Promise.resolve(null);\n\n      if (typeof protocols === \"string\" || Array.isArray(protocols)) {\n        return Promise.resolve(protocols);\n      }\n\n      // @ts-expect-error redundant check\n      if (protocols.then) {\n        return protocols;\n      }\n    }\n\n    throw Error(\"Invalid protocols\");\n  }\n\n  private _getNextUrl(urlProvider: UrlProvider): Promise<string> {\n    if (typeof urlProvider === \"string\") {\n      return Promise.resolve(urlProvider);\n    }\n    if (typeof urlProvider === \"function\") {\n      const url = urlProvider();\n      if (typeof url === \"string\") {\n        return Promise.resolve(url);\n      }\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-expect-error\n      if (url.then) {\n        return url;\n      }\n\n      // return url;\n    }\n    throw Error(\"Invalid URL\");\n  }\n\n  private _connect() {\n    if (this._connectLock || !this._shouldReconnect) {\n      return;\n    }\n    this._connectLock = true;\n\n    const {\n      maxRetries = DEFAULT.maxRetries,\n      connectionTimeout = DEFAULT.connectionTimeout\n    } = this._options;\n\n    if (this._retryCount >= maxRetries) {\n      this._debug(\"max retries reached\", this._retryCount, \">=\", maxRetries);\n      return;\n    }\n\n    this._retryCount++;\n\n    this._debug(\"connect\", this._retryCount);\n    this._removeListeners();\n\n    this._wait()\n      .then(() =>\n        Promise.all([\n          this._getNextUrl(this._url),\n          this._getNextProtocols(this._protocols || null)\n        ])\n      )\n      .then(([url, protocols]) => {\n        // close could be called before creating the ws\n        if (this._closeCalled) {\n          this._connectLock = false;\n          return;\n        }\n        if (\n          !this._options.WebSocket &&\n          typeof WebSocket === \"undefined\" &&\n          !didWarnAboutMissingWebSocket\n        ) {\n          console.error(`‼️ No WebSocket implementation available. You should define options.WebSocket. \n\nFor example, if you're using node.js, run \\`npm install ws\\`, and then in your code:\n\nimport PartySocket from 'partysocket';\nimport WS from 'ws';\n\nconst partysocket = new PartySocket({\n  host: \"127.0.0.1:1999\",\n  room: \"test-room\",\n  WebSocket: WS\n});\n\n`);\n          didWarnAboutMissingWebSocket = true;\n        }\n        const WS: typeof WebSocket = this._options.WebSocket || WebSocket;\n        this._debug(\"connect\", { url, protocols });\n        this._ws = protocols ? new WS(url, protocols) : new WS(url);\n\n        this._ws.binaryType = this._binaryType;\n        this._connectLock = false;\n        this._addListeners();\n\n        this._connectTimeout = setTimeout(\n          () => this._handleTimeout(),\n          connectionTimeout\n        );\n      })\n      // via https://github.com/pladaria/reconnecting-websocket/pull/166\n      .catch((err) => {\n        this._connectLock = false;\n        this._handleError(new Events.ErrorEvent(Error(err.message), this));\n      });\n  }\n\n  private _handleTimeout() {\n    this._debug(\"timeout event\");\n    this._handleError(new Events.ErrorEvent(Error(\"TIMEOUT\"), this));\n  }\n\n  private _disconnect(code = 1000, reason?: string) {\n    this._clearTimeouts();\n    if (!this._ws) {\n      return;\n    }\n    this._removeListeners();\n    try {\n      if (\n        this._ws.readyState === this.OPEN ||\n        this._ws.readyState === this.CONNECTING\n      ) {\n        this._ws.close(code, reason);\n      }\n      this._handleClose(new Events.CloseEvent(code, reason, this));\n    } catch (_error) {\n      // ignore\n    }\n  }\n\n  private _acceptOpen() {\n    this._debug(\"accept open\");\n    this._retryCount = 0;\n  }\n\n  private _handleOpen = (event: Event) => {\n    this._debug(\"open event\");\n    const { minUptime = DEFAULT.minUptime } = this._options;\n\n    clearTimeout(this._connectTimeout);\n    this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);\n\n    assert(this._ws, \"WebSocket is not defined\");\n\n    this._ws.binaryType = this._binaryType;\n\n    // send enqueued messages (messages sent before websocket open event)\n    this._messageQueue.forEach((message) => {\n      this._ws?.send(message);\n    });\n    this._messageQueue = [];\n\n    if (this.onopen) {\n      this.onopen(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _handleMessage = (event: MessageEvent) => {\n    this._debug(\"message event\");\n\n    if (this.onmessage) {\n      this.onmessage(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _handleError = (event: ErrorEvent) => {\n    this._debug(\"error event\", event.message);\n    this._disconnect(\n      undefined,\n      event.message === \"TIMEOUT\" ? \"timeout\" : undefined\n    );\n\n    if (this.onerror) {\n      this.onerror(event);\n    }\n    this._debug(\"exec error listeners\");\n    this.dispatchEvent(cloneEvent(event));\n\n    this._connect();\n  };\n\n  private _handleClose = (event: CloseEvent) => {\n    this._debug(\"close event\");\n    this._clearTimeouts();\n\n    if (this._shouldReconnect) {\n      this._connect();\n    }\n\n    if (this.onclose) {\n      this.onclose(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _removeListeners() {\n    if (!this._ws) {\n      return;\n    }\n    this._debug(\"removeListeners\");\n    this._ws.removeEventListener(\"open\", this._handleOpen);\n    this._ws.removeEventListener(\"close\", this._handleClose);\n    this._ws.removeEventListener(\"message\", this._handleMessage);\n    // @ts-expect-error we need to fix event/listerner types\n    this._ws.removeEventListener(\"error\", this._handleError);\n  }\n\n  private _addListeners() {\n    if (!this._ws) {\n      return;\n    }\n    this._debug(\"addListeners\");\n    this._ws.addEventListener(\"open\", this._handleOpen);\n    this._ws.addEventListener(\"close\", this._handleClose);\n    this._ws.addEventListener(\"message\", this._handleMessage);\n    // @ts-expect-error we need to fix event/listener types\n    this._ws.addEventListener(\"error\", this._handleError);\n  }\n\n  private _clearTimeouts() {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._uptimeTimeout);\n  }\n}\n", "import ReconnectingWebSocket from \"./ws\";\n\nimport type * as RWS from \"./ws\";\n\ntype Maybe<T> = T | null | undefined;\ntype Params = Record<string, Maybe<string>>;\nconst valueIsNotNil = <T>(\n  keyValuePair: [string, Maybe<T>]\n): keyValuePair is [string, T] =>\n  keyValuePair[1] !== null && keyValuePair[1] !== undefined;\n\nexport type PartySocketOptions = Omit<RWS.Options, \"constructor\"> & {\n  id?: string; // the id of the client\n  host: string; // base url for the party\n  room?: string; // the room to connect to\n  party?: string; // the party to connect to (defaults to main)\n  basePath?: string; // the base path to use for the party\n  prefix?: string; // the prefix to use for the party\n  protocol?: \"ws\" | \"wss\";\n  protocols?: string[];\n  path?: string; // the path to connect to\n  query?: Params | (() => Params | Promise<Params>);\n  disableNameValidation?: boolean; // disable validation of party/room names\n  // headers\n};\n\nexport type PartyFetchOptions = {\n  host: string; // base url for the party\n  room: string; // the room to connect to\n  party?: string; // the party to fetch from (defaults to main)\n  basePath?: string; // the base path to use for the party\n  prefix?: string; // the prefix to use for the party\n  path?: string; // the path to fetch from\n  protocol?: \"http\" | \"https\";\n  query?: Params | (() => Params | Promise<Params>);\n  fetch?: typeof fetch;\n};\n\nfunction generateUUID(): string {\n  // Public Domain/MIT\n  if (crypto?.randomUUID) {\n    return crypto.randomUUID();\n  }\n  let d = Date.now(); //Timestamp\n  let d2 = (performance?.now && performance.now() * 1000) || 0; //Time in microseconds since page-load or 0 if unsupported\n  // biome-ignore lint/complexity/useArrowFunction: it's fine\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n    let r = Math.random() * 16; //random number between 0 and 16\n    if (d > 0) {\n      //Use timestamp until depleted\n      r = ((d + r) % 16) | 0;\n      d = Math.floor(d / 16);\n    } else {\n      //Use microseconds since page-load if supported\n      r = ((d2 + r) % 16) | 0;\n      d2 = Math.floor(d2 / 16);\n    }\n    return (c === \"x\" ? r : (r & 0x3) | 0x8).toString(16);\n  });\n}\n\nfunction getPartyInfo(\n  partySocketOptions: PartySocketOptions | PartyFetchOptions,\n  defaultProtocol: \"http\" | \"ws\",\n  defaultParams: Record<string, string> = {}\n) {\n  const {\n    host: rawHost,\n    path: rawPath,\n    protocol: rawProtocol,\n    room,\n    party,\n    basePath,\n    prefix,\n    query\n  } = partySocketOptions;\n\n  // strip the protocol from the beginning of `host` if any\n  let host = rawHost.replace(/^(http|https|ws|wss):\\/\\//, \"\");\n  // if user provided a trailing slash, remove it\n  if (host.endsWith(\"/\")) {\n    host = host.slice(0, -1);\n  }\n\n  if (rawPath?.startsWith(\"/\")) {\n    throw new Error(\"path must not start with a slash\");\n  }\n\n  const name = party ?? \"main\";\n  const path = rawPath ? `/${rawPath}` : \"\";\n  const protocol =\n    rawProtocol ||\n    (host.startsWith(\"localhost:\") ||\n    host.startsWith(\"127.0.0.1:\") ||\n    host.startsWith(\"192.168.\") ||\n    host.startsWith(\"10.\") ||\n    (host.startsWith(\"172.\") &&\n      host.split(\".\")[1] >= \"16\" &&\n      host.split(\".\")[1] <= \"31\") ||\n    host.startsWith(\"[::ffff:7f00:1]:\")\n      ? // http / ws\n        defaultProtocol\n      : // https / wss\n        `${defaultProtocol}s`);\n\n  const baseUrl = `${protocol}://${host}/${basePath || `${prefix || \"parties\"}/${name}/${room}`}${path}`;\n\n  const makeUrl = (query: Params = {}) =>\n    `${baseUrl}?${new URLSearchParams([\n      ...Object.entries(defaultParams),\n      ...Object.entries(query).filter(valueIsNotNil)\n    ])}`;\n\n  // allow urls to be defined as functions\n  const urlProvider =\n    typeof query === \"function\"\n      ? async () => makeUrl(await query())\n      : makeUrl(query);\n\n  return {\n    host,\n    path,\n    room,\n    name,\n    protocol,\n    partyUrl: baseUrl,\n    urlProvider\n  };\n}\n\n// things that nathanboktae/robust-websocket claims are better:\n// doesn't do anything in offline mode (?)\n// \"natively aware of error codes\"\n// can do custom reconnect strategies\n\n// TODO: incorporate the above notes\nexport default class PartySocket extends ReconnectingWebSocket {\n  _pk!: string;\n  _pkurl!: string;\n  name!: string;\n  room?: string;\n  host!: string;\n  path!: string;\n\n  constructor(readonly partySocketOptions: PartySocketOptions) {\n    const wsOptions = getWSOptions(partySocketOptions);\n\n    super(wsOptions.urlProvider, wsOptions.protocols, wsOptions.socketOptions);\n\n    this.setWSProperties(wsOptions);\n\n    if (!partySocketOptions.disableNameValidation) {\n      if (partySocketOptions.party?.includes(\"/\")) {\n        console.warn(\n          `PartySocket: party name \"${partySocketOptions.party}\" contains forward slash which may cause routing issues. Consider using a name without forward slashes or set disableNameValidation: true to bypass this warning.`\n        );\n      }\n      if (partySocketOptions.room?.includes(\"/\")) {\n        console.warn(\n          `PartySocket: room name \"${partySocketOptions.room}\" contains forward slash which may cause routing issues. Consider using a name without forward slashes or set disableNameValidation: true to bypass this warning.`\n        );\n      }\n    }\n  }\n\n  public updateProperties(partySocketOptions: Partial<PartySocketOptions>) {\n    const wsOptions = getWSOptions({\n      ...this.partySocketOptions,\n      ...partySocketOptions,\n      host: partySocketOptions.host ?? this.host,\n      room: partySocketOptions.room ?? this.room,\n      path: partySocketOptions.path ?? this.path\n    });\n\n    this._url = wsOptions.urlProvider;\n    this._protocols = wsOptions.protocols;\n    this._options = wsOptions.socketOptions;\n\n    this.setWSProperties(wsOptions);\n  }\n\n  private setWSProperties(wsOptions: ReturnType<typeof getWSOptions>) {\n    const { _pk, _pkurl, name, room, host, path } = wsOptions;\n\n    this._pk = _pk;\n    this._pkurl = _pkurl;\n    this.name = name;\n    this.room = room;\n    this.host = host;\n    this.path = path;\n  }\n\n  public reconnect(\n    code?: number | undefined,\n    reason?: string | undefined\n  ): void {\n    if (!this.room || !this.host) {\n      throw new Error(\n        \"The room and host must be set before connecting, use `updateProperties` method to set them or pass them to the constructor.\"\n      );\n    }\n    super.reconnect(code, reason);\n  }\n\n  get id() {\n    return this._pk;\n  }\n\n  /**\n   * Exposes the static PartyKit room URL without applying query parameters.\n   * To access the currently connected WebSocket url, use PartySocket#url.\n   */\n  get roomUrl(): string {\n    return this._pkurl;\n  }\n\n  // a `fetch` method that uses (almost) the same options as `PartySocket`\n  static async fetch(\n    options: PartyFetchOptions,\n    init?: RequestInit\n  ): Promise<Response> {\n    const party = getPartyInfo(options, \"http\");\n    const url =\n      typeof party.urlProvider === \"string\"\n        ? party.urlProvider\n        : await party.urlProvider();\n    const doFetch = options.fetch ?? fetch;\n    return doFetch(url, init);\n  }\n}\n\nexport { PartySocket };\n\nexport { ReconnectingWebSocket as WebSocket };\n\nfunction getWSOptions(partySocketOptions: PartySocketOptions) {\n  const {\n    id,\n    host: _host,\n    path: _path,\n    party: _party,\n    room: _room,\n    protocol: _protocol,\n    query: _query,\n    protocols,\n    ...socketOptions\n  } = partySocketOptions;\n\n  const _pk = id || generateUUID();\n  const party = getPartyInfo(partySocketOptions, \"ws\", { _pk });\n\n  return {\n    _pk: _pk,\n    _pkurl: party.partyUrl,\n    name: party.name,\n    room: party.room,\n    host: party.host,\n    path: party.path,\n    protocols: protocols,\n    socketOptions: socketOptions,\n    urlProvider: party.urlProvider\n  };\n}\n"],
  "mappings": "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",
  "names": ["ReconnectingWebSocket"]
}
